---
title: "_monitoraSom_: pacote de R para detecção de sinais usando template matching"
subtitle: "Roteiro para a oficina do I Simpósio de Física aplicada à Ecologia e Conservação"
author: "Gabriel L. M. Rosa"
date: "`r Sys.Date()`"
output:
  rmdformats::downcute:
    number_sections: true
    self_contained: true
    thumbnails: true
    lightbox: true
    gallery: false
    highlight: tango
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Instalação e setup inicial

Seja bem-vindo(a) ao tutorial do monitoraSom! Nessa primeira etapa, vamos fazer os downloads e instalações necessárias para o uso do monitoraSom.

### 1. Baixar e instalar o R.

- Verifique se já existe alguma versão instalada.
- Ao fazer uma nova instalação, dê preferência para a versão mais recente.
- link para download: https://cran.r-project.org/bin/windows/base/

### 2. Baixar e instalar o Rstudio.
- Após instalar o R, instale o Rstudio.
- Atenção: se houver mais de uma versão do R instalada, certifique-se qual está sendo usada ao abrir o Rstudio.
- link para download: https://posit.co/download/rstudio-desktop/

### 3. Instalar o Rtools (passo necessário apenas para usuários do Windows)
- Rtools é necessário para compilar pacotes do R que foram instalados a partir do GitHub.
- Verifique se já existe alguma versão instalada. Caso exista, verifique se é adequada ao projeto. Se não for, desinstale a versão existente.
- Neste momento, a versão mais recente é a 4.5.
- link para download: https://cran.r-project.org/bin/windows/Rtools/

### 4. Criar uma nova pasta para conter os arquivos usandos pelo monitoraSom.
Para usuários do Windows, recomendamos criar uma pasta para análises na raiz do sistema, e dentro dela uma pasta para este projeto, por exemplo, "C:/Meus Projetos/monitoraSom_tutorial". Dessa forma o caminho para os arquivos será o mesmo mesmo que os arquivos sejam movidos para outro computador.

### 5. Instalar o devtools para poder instalar pacotes a partir do GitHub.
Esse comando deve ser executado no Rstudio após a instalação do Rtools.
```{r eval=FALSE, include=TRUE}
install.packages("devtools")
```

### 6. Carregar o devtools para o ambiente de trabalho.
```{r eval=FALSE, include=TRUE}
library(devtools)
```

### 7. Instalar o monitoraSom
- O monitoraSom depende de outros pacotes do R para funcionar adequadamente.
- Atenção 1: A isntalação poderá solicitar a confirmação de instalação das dependências. Recomendamos que seja feita a instalação ou atualização de todas as dependências respondendo '1' ("All").
- Atenção 2: Pode ser solictada também a resposta sobre instalação de pacotes de precisam de compilação. Nesse caso, responda 'Yes'.
```{r eval=FALSE, include=TRUE}
install_github("ConservaSom/monitoraSom", dependencies = TRUE)
```

### 8. Carregar o monitoraSom no ambiente de trabalho do R para testar a instalação.
```{r message=FALSE, warning=FALSE}
library(monitoraSom)
library(dplyr)
```

### 9. Salvar esse script no diretório de trabalho conforme descrito no passo 4.
Priorize salvar com um nome informativo e que mantenha a sequência de passos desse e dos tutoriais seguintes, por exemplo, "script_01_instalação.R".

### Checkpoint 01
Você instalou o monitoraSom e está pronto para começar a usar. Salve esse script no diretório de trabalho conforme descrito no passo 4.

### 10. Organizando o ambiente de trabalho.
Vamos seguir a partir deste ponto assumindo que o diretório de trabalho está organizado conforme descrito no passo 4 e que o código está salvo em um arquivo em formato de script ou notebook (Rmarkdown ou Quarto).

Vamos verificar e, se necessário, ajustar manualmente o diretório de trabalho da sessão atual.
```{r}
getwd()
```

Se o script estiver no diretório de trabalho correto, use o comando abaixo para definir o diretório automaticamente.
```{r}
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
getwd() # Verificando se o diretório de trabalho foi definido corretamente
```

Se quiser definir manualmente o diretório de trabalho, use o comando abaixo.
```{r eval=FALSE}
project_path <- paste0(
    "<coloque aqui o caminho para a pasta do projeto>", "/monitoraSom"
)
setwd(project_path)
getwd() # Verificando se o diretório de trabalho foi definido corretamente
```

```{r eval=TRUE, echo=FALSE}
project_path <- paste0(
    getwd(), "/monitoraSom"
)
setwd(project_path)
getwd() # Verificando se o diretório de trabalho foi definido corretamente
```

### 11. Povoando o diretório de trabalho com os arquivos de exemplo do monitoraSom.
Use a função `set_workspace` para adicionar os arquivos de exemplo do monitoraSom ao seu diretório de trabalho. Esse comando é recomendado para novos projetos. Evite executá-lo em diretórios que já contenham dados de projetos em andamento. Isso poderá resultar em perdas permanentes de dados.
```{r eval=FALSE}
set_workspace(project_path = "./", example_data = TRUE)
```

Vamos fazer algumas checagens para verificar se os arquivos de exemplo foram depositados corretamente. Em um prjeto recém iniciado, o usuário deverá ter pelo menos os arquivos das soundscapes, e caso deseje extrair templates de outras gravações, uma pasta chamada "recordings". Todos os demais arquivos estão precarregados no pacote para facilitar o uso do monitoraSom. Caso não tenha os arquivos de exemplo, execute o comando `set_workspace` novamente.

Estes são os arquivos das soundscapes onde buscamos a espécie alvo:
```{r}
list.files("./soundscapes/", full.names = TRUE)
```

Estes são os arquivos das gravações focais de onde serão extraídos templates:
```{r}
list.files("./recordings/", full.names = TRUE)
```

Estes são os arquivos com as regiões de interesse determinadas nas gravações focais e soundscapes:
```{r}
list.files("./roi_tables/", full.names = TRUE)
```

### 12. (Opcional) Limpeza de arquivos pre-carregados
Vamos apagar os arquivos de exemplo para continuar o tutorial como um novo projeto. Pule esta etapa se quiser obter os mesmos resultados do tutorial.
```{r eval=FALSE}
file.remove(list.files("./detections/", full.names = TRUE))
file.remove(list.files("./match_grid_metadata/", full.names = TRUE))
file.remove(list.files("./match_scores/", full.names = TRUE))
file.remove(list.files("./soundscapes_metadata/", full.names = TRUE))
file.remove(list.files("./templates/", full.names = TRUE))
file.remove(list.files("./templates_metadata/", full.names = TRUE))
file.remove(list.files("./validation_outputs/", full.names = TRUE))
```

### Checkpoint 02
Você povoou o diretório de trabalho com os arquivos de exemplo do monitoraSom e está pronto para seguir com o uso do pacote. Apague os arquivos de exemplo se quiser começar um novo projeto.

### 13. Usar o app de segmentação para escolher os templates.
Agora vamos usar o app de segmentação para escolher os templates. Note que como estamos somente escolhendo os templates, definimos o destino dos cortes de audio para a pasta "./templates". Os templates são as amostras de som que desejamos usar para detecção nos passos seguintes. Podemos exportar os templates manualmente de dentro do app, mas nesse tutorial vamos usar o app somente para demarcar as ROIs, para depois exportar os cortes de audio automaticamente (ver passo 16).
```{r eval=FALSE}
launch_segmentation_app(
    user = "User", # Nome do usuário
    project_path = "./", # Caminho para a pasta do projeto
    preset_path = "./app_presets/", # Caminho para a pasta de presets
    soundscapes_path = "./recordings/", # Caminho onde ler as gravações
    roi_tables_path = "./roi_tables/", # Caminho para onde exportar as ROIs
    cuts_path = "./templates/", # Caminho para onde exportar cortes de audio
    dyn_range = c(-102, -42), # Ajuste do contraste do espectrograma
    wl = 1024, # Ajuste do comprimento da janela do fft (parametro espectral)
    ovlp = 50, # Ajuste da sobreposição do fft (parametro espectral)
    color_scale = "greyscale 1", # Ajuste da escala de cores do espectrograma
    nav_autosave = TRUE # Auomtação de salvamento ao trocar de soundscape
)
```

### 14. Usar o app de segmentação para segmentar as soundscapes.
Agora vamos usar o app de segmentação para segmentar as soundscapes. Nessa etapa, definimos o destino dos cortes de audio para a pasta "./roi_cuts". As tabelas de ROIs que serão produzidas nessa etapa serão usadas para avaliar as detecções e medir a poerformance de cada template.
```{r eval=FALSE}
launch_segmentation_app(
    user = "User", project_path = "./", preset_path = "./app_presets/",
    soundscapes_path = "./soundscapes/", roi_tables_path = "./roi_tables/",
    cuts_path = "./roi_cuts/", dyn_range = c(-102, -42), wl = 1024, ovlp = 50,
    color_scale = "greyscale 1", visible_bp = TRUE, nav_autosave = TRUE
)
```

### 15. Preparando os templates.
Vamos importar todas as tabelas de ROIs para verificarmos se temos o que precisamos. Note que as tabelas de ROIs das soundscapes e dos templates encontram-se na mesma pasta, mas podemos discriminá-las facilmentepelo nome do arquivo.
```{r}
df_templates <- fetch_rois(rois_path = "./roi_tables/")
unique(df_templates$soundscape_file) # Verificando os nomes das gravações
```

Filtrando as tabelas de ROIs para manter somente aquelas com os templates.
```{r}
df_templates <- df_templates[grepl("Substructure C", df_templates$roi_comment), ]
unique(df_templates$soundscape_file) # Verificando os nomes das grava<U+00E7><U+00F5>es
```

### 16. Exportando os cortes de audio dos templates.
Para exportar os cortes de audio dos templates, usamos a função `export_roi_cuts()`. Note que os cortes de audio serão exportados para a pasta "./templates".
```{r eval=FALSE}
export_roi_cuts(df_rois = df_templates, roi_cuts_path = "./templates/")
list.files(path = "./templates/", pattern = "Bcu", full.names = TRUE)
```

### Checkpoint 03
Aqui você deve decidir: se deseja seguir com o processo simplificado (função `template matching()`) execute o passo 17, ou se deseja seguir com o processo detalhado, execute os passos 18-21.
<!-- todo Definir os passos aqui -->

### 17. Obtendo as detecções (processo simplificado)
Vamos usar o processo simplificado para obter as detecções. Esse processo é mais rápido e fácil, mas menos flexível. Ele é recomendado para projetos pequenos e para quem deseja obter rapidamente os resultados. Nesse caso vamos exportar os resultados para o arquivo "./detections/df_detections.csv" e usar 4 núcleos para processamento paralelo, para ganhar um pouco de velocidade.
```{r}
template_matching(
    soundscapes_path = "./soundscapes/", # local de origem das soundscapes
    templates_path = "./templates/", # local de origem dos templates
    output_file = "./detections/df_detections.csv", # resultado (detecções)
    ncores = 4
)
```

### 18. Processando os metadados das soundscapes (processo detalhado).

No processo detalhado, precisamos reunir os metadados das soundscapes e dos templates separadamente. Vamos começar pelas soundscapes.
```{r eval=FALSE}
df_soundscapes <- fetch_soundscape_metadata(
    soundscapes_path = "./soundscapes", # caminho para as soundscapes
    recursive = TRUE, # se TRUE, lê subdiretórios de forma recursiva
    # caminho para onde exportar o arquivo de metadados
    output_file = "./soundscapes_metadata/df_soundscapes.csv",
    ncores = 4, # quantidade de núcleos para processamento paralelo
    # se TRUE, pula o processamento de arquivos já registrados nos metadados
    skip_processed = TRUE
)
glimpse(df_soundscapes)
```

### 19. Processando os metadados dos templates (processo detalhado).
Agora vamos importar os metadados dos templates.
```{r}
df_templates <- fetch_template_metadata(
    templates_path = "./templates/", recursive = TRUE
)
glimpse(df_templates)
```

### 20. Juntando os metadados das soundscapes e dos templates (processo detalhado).
O template matching pode ser custoso para grandes quantidades de arquivos. O processo detalhado permite filtrar e organizar os dados antes do processamento total. A função `fetch_match_grid()` combina os metadados das soundscapes e templates e checa incompatibilidades, como taxas de amostragem diferentes.
```{r}
df_grid <- fetch_match_grid(
    soundscape_data = df_soundscapes, template_data = df_templates
)
glimpse(df_grid)
```

### 21. Obtendo as detecções (processo detalhado)
Agora vamos rodar o template matching usando a grade produzida acima como referência. Abaixo mostramos como rodar o template matching usando a função `run_matching()` e mais alguns recursos que essa função oferece.
```{r}
df_detections <- run_matching(
    df_grid = df_grid,
    output_file = "./detections/df_detections.csv", # arquivo com as detecções
    autosave_action = "replace", # ação ao salvar o arquivo
    buffer_size = "template", # buffer para evitar detecções sobrepostas
    ncores = 4 # quantidade de núcleos para processamento em paralelo
)
glimpse(df_detections)
```

Dentre as opções disponíveis para o argumento `autosave_action`, temos:
- "replace": sobrescreve o arquivo existente.
- "append": adiciona os resultados ao arquivo existente, mas deve ser usado com cuidado para evitar detecções duplicadas ao importar o arquivo.

Dentre as opções disponíveis para o argumento `buffer_size`, temos:
- "template": buffer para evitar detecções sobrepostas em uma região de mesma duração do template.
- Valores inteiros: define a quantidade de frames para o buffer.
- 0: desliga o buffer, permitindo detecções sobrepostas em uma região de mesma duração do template. Essa opção é recomendada somente para projetos em que a validação não será realizada manualmente, já que retém muitas detecções redundantes.

Outras opções de filtragem disponíveis são:
- `min_score`: define o score mínimo para detecção. Essa opção determina um limiar mínimo para a detecção, excluindo todas as detecções com scores inferiores ao valor especificado. Deve ser usada com cuidadado, pois pode eliminar completamente soundscapes e templates sem scores acima do limiar especificado, e assim eliminar a possibilidade de contagem correta de FN (False Negatives) para validação a priori (ver passo XX).
  <!-- todo Definir o passo de validação a priori -->
- `min_quant`: define o quantil mínimo para detecção. Essa opção avalia o quantil dentro de cada rodada de busca, excluindo todas as detecções com scores inferiores ao quantil especificado. Como o quantil é uma medida relativa, retornará sempre ao menos uma detecção para cada rodada de busca.
- `top_n`: define de forma explícita a quantidade de detecções com os scores mais altos a serem retidas. Essa opção retornará sempre a quantidade de detecções especificada, independente do valor máximo e mínimo de scores obtidos.


### 22. Caso especial: Obtendo os scores brutos.
Vamos usar a função `run_matching()` para fazer as buscas na grade definida, exatamente como no passo 21, mas vamos adicionar o argumento `output = "scores"` para obter os scores brutos ao invés de ir direto para as detecções. Note que mudamos dois argumentos: `output` e `output_file`. `output` define o tipo de resultado que será retornado e `output_file` define o caminho para o arquivo de saída, que agora será um arquivo RDS em vez de CSV.
```{r}
df_scores <- run_matching(
    df_grid = df_grid,
    output = "scores", # arquivo com os scores brutos
    output_file = "./detections/df_scores.rds", # arquivo com os scores brutos
    ncores = 4 # quantidade de núcleos para processamento em paralelo
)
glimpse(df_scores)
```

### Checkpoint 04
Você obteve as detecções, mas veja que ainda não sabe quais delas são verdadeiras e quais são falsas. Nesse checkpoint você poderá fazer fitragens adicionais às demonstradas no passo acima segundo os critérios do seu projeto.

