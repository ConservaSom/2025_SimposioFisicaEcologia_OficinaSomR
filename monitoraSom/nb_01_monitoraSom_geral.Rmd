---
title: "_monitoraSom_: pacote de R para detecção de sinais usando template matching"
subtitle: "Roteiro para a oficina do I Simpósio de Física aplicada à Ecologia e Conservação"
author: "Gabriel L. M. Rosa"
date: "`r Sys.Date()`"
output:
  pdf_document:
    toc: yes
    toc_depth: 5
    number_sections: no
---

<style>
body {
text-align: justify}
</style>

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## 1. Instalação e configuração inicial

Seja bem-vindo(a) ao tutorial do monitoraSom! Nessa primeira etapa, vamos fazer os downloads e instalações necessárias para o uso do monitoraSom.

### 1.1. Baixar e instalar o R

- Verifique se já existe alguma versão instalada.
- Ao fazer uma nova instalação, dê preferência para a versão mais recente.
- link para download: https://cran.r-project.org/bin/windows/base/

### 1.2. Baixar e instalar o Rstudio
- Após instalar o R, instale o Rstudio.
- Atenção: se houver mais de uma versão do R instalada, certifique-se qual está sendo usada ao abrir o Rstudio.
- link para download: https://posit.co/download/rstudio-desktop/

### 1.3. Instalar o Rtools (passo necessário apenas para usuários do Windows)
- Rtools é necessário para compilar pacotes do R que foram instalados a partir do GitHub.
- Verifique se já existe alguma versão instalada. Caso exista, verifique se é adequada ao projeto. Se não for, desinstale a versão existente.
- Neste momento, a versão mais recente é a 4.5.
- link para download: https://cran.r-project.org/bin/windows/Rtools/

### 1.4. Criar uma nova pasta para conter os arquivos usados pelo monitoraSom
Recomenda-se criar uma pasta para análises na raiz do sistema (ex: "C:/Meus Projetos/monitoraSom_tutorial"), garantindo que os caminhos permaneçam consistentes mesmo ao mover arquivos entre computadores.

### 1.5. Instalar o devtools
Instala o pacote `devtools`, necessário para instalar pacotes diretamente do GitHub. Execute no RStudio após instalar o Rtools (apenas Windows).
```{r eval=FALSE, include=TRUE}
install.packages("devtools")
```

### 1.6. Carregar o devtools
```{r eval=FALSE, include=TRUE}
library(devtools)
```

### 1.7. Instalar o monitoraSom
Instala o pacote `monitoraSom` e suas dependências diretamente do GitHub. Durante a instalação:
- Se solicitado, responda '1' para instalar todas as dependências ("All")
- Se solicitado sobre compilação, responda 'Yes'
```{r eval=FALSE, include=TRUE}
install_github("ConservaSom/monitoraSom", dependencies = TRUE)
```

### 1.8. Carregar o monitoraSom no ambiente de trabalho do R para testar a instalação
```{r message=FALSE, warning=FALSE}
library(monitoraSom)
library(dplyr)
library(ggplot2)
library(patchwork)
```

### 1.9. Salvar o script
Salve o script no diretório de trabalho (passo 1.4) com nome descritivo, por exemplo: "script_01_instalação.R".

### 1.10. Checkpoint 01 - Instalação do monitoraSom
Você instalou o monitoraSom e está pronto para começar a usar. Salve esse script no diretório de trabalho conforme descrito no passo 1.4.

## 2. Organizando o ambiente de trabalho
Vamos seguir a partir deste ponto assumindo que o diretório de trabalho está organizado conforme descrito no passo 1.4 e que o código está salvo em um arquivo em formato de script ou notebook (Rmarkdown ou Quarto).

### 2.1. Verificar e ajustar o diretório de trabalho
Verifica o diretório de trabalho atual. Se necessário, ajuste usando um dos métodos abaixo.
```{r }
getwd()
```

**Método 1 - Automático (recomendado):** Define o diretório automaticamente baseado na localização do script.
```{r eval=FALSE}
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
getwd()
```

**Método 2 - Manual:** Define o caminho manualmente para o diretório do projeto.
```{r eval=FALSE}
project_path <- paste0(
    "<coloque aqui o caminho para a pasta do projeto>", "/monitoraSom"
)
setwd(project_path)
getwd()
```

```{r eval=FALSE, echo=FALSE}
project_path <- paste0(getwd(), "/monitoraSom")
setwd(project_path)
getwd() # Verificando se o diretório de trabalho foi definido corretamente
```

### 2.2. Carregar arquivos de exemplo
Cria a estrutura de diretórios e carrega arquivos de exemplo necessários para o tutorial. **Atenção:** Execute apenas em projetos novos, pois pode sobrescrever dados existentes.
```{r eval=FALSE}
set_workspace(project_path = "./", example_data = TRUE)
```

### 2.3. (Opcional) Limpar arquivos de exemplo
Remove os arquivos de exemplo para iniciar um projeto do zero. Pule esta etapa se desejar usar os dados de exemplo originais.
```{r eval=FALSE}
file.remove(list.files("./detections/", full.names = TRUE))
file.remove(list.files("./match_grid_metadata/", full.names = TRUE))
file.remove(list.files("./match_scores/", full.names = TRUE))
file.remove(list.files("./soundscapes_metadata/", full.names = TRUE))
file.remove(list.files("./templates/", full.names = TRUE))
file.remove(list.files("./templates_metadata/", full.names = TRUE))
file.remove(list.files("./validation_outputs/", full.names = TRUE))
```

### 2.4. Checkpoint 02 - Povoamento do diretório de trabalho com os arquivos de exemplo
Você povoou o diretório de trabalho com os arquivos de exemplo do monitoraSom e está pronto para seguir com o uso do pacote. Apague os arquivos de exemplo se quiser começar um novo projeto.

## 3. Preparação de templates e soundscapes

### 3.1. Selecionar templates usando o app de segmentação
Abre o app de segmentação para marcar as regiões de interesse (ROIs) que servirão como templates. Os templates são amostras de som usadas para detecção automática. Neste passo, definimos `cuts_path = "./templates/"` para indicar onde os cortes serão exportados. Os templates serão exportados automaticamente no passo 3.4.

**Nota:** No exemplo, os ROIs já estão criados. Para criar um novo template, marque um canto completo e adicione o comentário "Complete Song".
```{r eval=FALSE}
launch_segmentation_app(
    user = "User", # Nome do usuário
    project_path = "./", # Caminho para a pasta do projeto
    preset_path = "./app_presets/", # Caminho para a pasta de presets
    soundscapes_path = "./recordings/", # Caminho onde ler as gravações
    roi_tables_path = "./roi_tables/", # Caminho para onde exportar as ROIs
    cuts_path = "./templates/", # Caminho para onde exportar cortes de audio
    dyn_range = c(-102, -42), # Ajuste do contraste do espectrograma
    wl = 1024, # Ajuste do comprimento da janela do fft (parametro espectral)
    ovlp = 50, # Ajuste da sobreposição do fft (parametro espectral)
    color_scale = "greyscale 1", # Ajuste da escala de cores do espectrograma
    nav_autosave = TRUE # Auomtação de salvamento ao trocar de soundscape
)
```

### 3.2. Segmentar as soundscapes
Abre o app de segmentação para marcar ROIs nas soundscapes. As tabelas de ROIs geradas serão usadas para validar as detecções e avaliar o desempenho dos templates. Os cortes de áudio são salvos em `./roi_cuts/`. **Nota:** No exemplo, a segmentação já está completa; não é necessário marcar novas ROIs.
```{r eval=FALSE}
launch_segmentation_app(
    user = "User", project_path = "./", preset_path = "./app_presets/",
    soundscapes_path = "./soundscapes/", roi_tables_path = "./roi_tables/",
    dyn_range = c(-102, -42), wl = 1024, ovlp = 50,
    color_scale = "greyscale 1", visible_bp = TRUE, nav_autosave = TRUE
)
```

### 3.3. Preparar os templates
Importa todas as tabelas de ROIs e filtra apenas aquelas marcadas como templates. As ROIs de templates e soundscapes estão na mesma pasta, mas podem ser diferenciadas pelo nome do arquivo ou comentário.
```{r}
df_rois <- fetch_rois(rois_path = "./roi_tables/")
unique(df_rois$soundscape_file) # Verificando os nomes das gravações
```

Filtra as ROIs para manter apenas os templates desejados (uma amostra de cada um dos tipos de interesse).
```{r}
df_templates <- df_rois %>%
    filter(roi_comment %in% c("Substructure C", "Complete Song")) %>%
    group_by(roi_comment) %>%
    sample_n(1)
glimpse(df_templates)
```

### 3.4. Exportar os cortes de áudio dos templates
Extrai e salva os cortes de áudio das ROIs marcadas como templates na pasta `./templates/`.
```{r eval=FALSE}
export_roi_cuts(
    df_rois = df_templates, roi_cuts_path = "./templates/", overwrite = FALSE
)
list.files(path = "./templates/", pattern = "Bcu", full.names = TRUE)
```

### 3.5. Checkpoint 03 - Decisão sobre o método de processamento
Aqui você deve decidir: se deseja seguir com o processo simplificado (função `template_matching()`) execute o passo 4.1, ou se deseja seguir com o processo detalhado, execute os passos 4.2-4.5.

## 4. Obtendo as detecções

### 4.1. Processo simplificado
Método mais rápido e direto para obter detecções, recomendado para projetos pequenos. A função `template_matching()` processa automaticamente todos os arquivos e retorna as detecções. Usa 4 núcleos para processamento paralelo.
```{r}
df_detecs <- template_matching(
    soundscapes_path = "./soundscapes/",
    templates_path = "./templates/",
    ncores = 4
)
glimpse(df_detecs)
```

### 4.2. Processo detalhado: metadados das soundscapes
No processo detalhado, os metadados são processados separadamente, permitindo maior controle e filtragem antes do template matching. Começamos coletando informações das soundscapes (duração, taxa de amostragem, caminho, etc.).
```{r}
df_soundscapes <- fetch_soundscape_metadata(
    soundscapes_path = "./soundscapes",
    recursive = TRUE, # Inclui subdiretórios
    ncores = 4 # Processamento paralelo
)
glimpse(df_soundscapes)
```

Visualização dos espectrogramas das duas primeiras soundscapes para verificar a importação correta.
```{r eval=TRUE, echo=FALSE}
cowplot::plot_grid(
    tuneR::readWave(filename = df_soundscapes$soundscape_path[1]) %>%
        fast_spectro(
            rec = ., f = .@samp.rate, wl = 1024, ovlp = 70,
            dyn_range = c(-102, -42), color_scale = "inferno",
            freq_guide_interval = 0, time_guide_interval = 0,
            tlim = c(0, 30)
        ) +
        theme_bw() +
        theme(legend.position = "none"),
    tuneR::readWave(filename = df_soundscapes$soundscape_path[4]) %>%
        fast_spectro(
            rec = ., f = .@samp.rate, wl = 1024, ovlp = 70,
            dyn_range = c(-102, -42), color_scale = "inferno",
            freq_guide_interval = 0, time_guide_interval = 0,
            tlim = c(0, 30)
        ) +
        theme_bw() +
        theme(legend.position = "none"),
    ncol = 1
)
```

### 4.3. Processo detalhado: metadados dos templates
Coleta os metadados dos templates (duração, frequências, taxa de amostragem, etc.). Mesmo que os templates já tenham sido importados no passo 3.3, este passo garante que os metadados estejam completos e atualizados.
```{r}
df_templates <- fetch_template_metadata(
    templates_path = "./templates/", recursive = TRUE
)
glimpse(df_templates)
```

```{r eval=TRUE, echo=FALSE}
templates_plots <- purrr::map(df_templates$template_path, ~ {
    wav <- tuneR::readWave(filename = .x)
    res <- fast_spectro(
        rec = wav, f = wav@samp.rate, wl = 1024, ovlp = 70,
        dyn_range = c(-102, -42), color_scale = "greyscale 1",
        freq_guide_interval = 0, time_guide_interval = 0,
        flim = c(
            min(df_templates$template_min_freq),
            max(df_templates$template_max_freq)
        )
    ) +
        theme_bw() +
        theme(legend.position = "none")
    return(res)
})
cowplot::plot_grid(
    templates_plots[[1]], templates_plots[[2]],
    ncol = 2, rel_widths = c(0.3, 1)
)
```

### 4.4. Processo detalhado: criar grade de busca
Cria uma grade combinando todas as combinações possíveis de soundscapes × templates. A função `fetch_match_grid()` verifica incompatibilidades (ex: taxas de amostragem diferentes) e permite filtrar dados antes do processamento, otimizando o template matching.
```{r}
df_grid <- fetch_match_grid(
    soundscape_data = df_soundscapes, template_data = df_templates
)
glimpse(df_grid)
```

### 4.5. Processo detalhado: executar template matching
Executa o template matching usando a grade criada no passo anterior. A função `run_matching()` oferece várias opções de filtragem e configuração, conforme detalhado abaixo.
```{r eval=FALSE}
run_matching(
    df_grid = df_grid,
    output_file = "./detections/df_detecs.csv",
    autosave_action = "replace", # Substitui arquivo existente
    buffer_size = "template", # Evita detecções sobrepostas
    ncores = 4
)
df_detecs <- read.csv(file = "./detections/df_detecs.csv")
glimpse(df_detecs)
```

**Opções de `autosave_action`:**
- `"replace"`: sobrescreve o arquivo existente
- `"append"`: adiciona resultados ao arquivo existente (cuidado com duplicatas)

**Opções de `buffer_size`:**
- `"template"`: buffer com duração igual ao template (evita sobreposições)
- Valor numérico: quantidade de frames para o buffer
- `0`: desliga o buffer (não recomendado para validação manual)

**Outras opções de filtragem:**
- `min_score`: score mínimo absoluto para detecção. **Cuidado:** pode eliminar templates/soundscapes sem detecções acima do limiar, impedindo cálculo correto de FN na validação (ver passo 5.1)
- `min_quant`: quantil mínimo relativo (sempre retorna pelo menos uma detecção por busca)
- `top_n`: quantidade fixa de detecções com maiores scores a serem retidas

### 4.6. Caso especial: obter scores brutos
Retorna os scores brutos (antes da filtragem) em vez das detecções processadas. Útil para análise detalhada e ajuste de limiares. O arquivo de saída será em formato RDS (não CSV).
```{r}
run_matching(
    df_grid = df_grid,
    output = "scores",
    output_file = "./detections/df_scores.rds",
    ncores = 4
)
glimpse(df_scores)
```

Importa os scores brutos de volta ao ambiente. O objeto mantém a estrutura da grade de busca, mas a coluna `score_vec` contém uma lista com data frames de scores por frame (tempo e score) para cada combinação template-soundscape.
```{r eval=FALSE}
df_scores <- readRDS(file = "./detections/df_scores.rds")
glimpse(df_scores)
```

Inspeciona a estrutura dos scores brutos: cada elemento de `score_vec` é um data frame com `time_vec` (tempo em segundos) e `score_vec` (score do template matching para cada frame do espectrograma).
```{r}
glimpse(df_scores$score_vec[[20]])
```

### 4.7. Visualizar os scores brutos
Visualiza os scores brutos ao longo do tempo para entender como as detecções foram geradas. A primeira visualização usa parâmetros padrão.
```{r}
plot_scores(df_scores_i = df_scores[7, ])
```

Visualização com parâmetros ajustados para melhor resolução e contraste.
```{r message=FALSE}
plot_scores(
    df_scores_i = df_scores[7, ], ovlp = 90, wl = 1024,
    dyn_range = c(-96, -48), color_scale = "inferno"
)
```

Zoom na região de tempo 5-10 segundos para visualizar um pico de detecção em detalhe.
```{r message=FALSE}
plot_scores(
    df_scores_i = df_scores[7, ], ovlp = 70, wl = 1024,
    dyn_range = c(-96, -48), color_scale = "inferno", zoom_time = c(5, 10)
)
```

Aplica filtros diretamente na visualização: buffer ativo e retenção das 6 detecções com maiores scores (`top_n = 6`). Útil para testar diferentes configurações antes de processar todas as detecções.
```{r message=FALSE}
plot_scores(
    df_scores_i = df_scores[7, ], ovlp = 70, wl = 1024,
    dyn_range = c(-96, -48), color_scale = "inferno",
    buffer_size = "template", top_n = 6
)
```

Testa filtro por score mínimo (`min_score = 0.1`) sem buffer. Neste exemplo, o limiar de 0.1 ainda retém algumas detecções falsas visíveis.
```{r message=FALSE}
plot_scores(
    df_scores_i = df_scores[7, ], ovlp = 70, wl = 1024,
    dyn_range = c(-96, -48), color_scale = "inferno",
    buffer_size = 0, min_score = 0.1
)
```

**Importante:** Os parâmetros de filtragem que funcionam para uma soundscape podem não ser adequados para outras. A validação sistemática é essencial para definir limiares ideais.
```{r message=FALSE}
plot_scores(
    df_scores_i = df_scores[11, ], ovlp = 70, wl = 1024,
    dyn_range = c(-96, -48), color_scale = "inferno",
    buffer_size = "template", min_score = 0.1
)
```

A avaliação visual é útil para ajuste inicial, mas a validação sistemática é necessária para definir limiares ideais. Extrai todas as detecções dos scores brutos sem filtros para validação completa.

```{r}
df_detecs_nofilt <- fetch_score_peaks(
    df_scores = df_scores,
    buffer_size = 0,
    output_file = "./detections/df_detecs_nofilt.csv"
)
glimpse(df_detecs_nofilt)
```

### 4.8. Checkpoint 04 - Filtragem adicional de detecções
Você obteve as detecções, mas veja que ainda não sabe quais são verdadeiras ou falsas. Nesse checkpoint você poderá fazer fitragens adicionais às demonstradas no passo acima segundo os critérios do seu projeto. Nesse ponto será necessário determinar qual método de validação será usado.

## 5. Validação das detecções

### 5.1. Validação a priori
Método automático baseado na sobreposição temporal entre detecções e ROIs pré-marcadas. Classifica cada detecção como TP (verdadeiro positivo), FP (falso positivo) ou FN (falso negativo). **Recomendado sempre que houver ROIs disponíveis**, pois permite contagem correta de FN e é muito mais rápido que validação manual.
```{r}
df_validated <- validate_by_overlap(
    df_detecs = df_detecs, df_rois = df_rois, validation_user = "User"
)
glimpse(df_validated)
```

### 5.2. Inspecionar resultados da validação
O objeto validado contém todas as variáveis das detecções originais, mais informações sobre as ROIs correspondentes. A coluna `validation` classifica cada detecção/ROI como:
- `TP`: verdadeiro positivo (detecção correta)
- `FP`: falso positivo (detecção incorreta)
- `FN`: falso negativo (ROI não detectada)

Contagem de validações por template:
```{r}
table(df_validated$validation, df_validated$template_name)
```

Comparação do número de detecções entre métodos:
```{r}
nrow(df_detecs)
nrow(df_detecs_nofilt)
```

Comparação de desempenho da validação a priori em diferentes cenários: o método é eficiente mesmo com grandes volumes de dados. A validação automática é muito mais rápida que a manual e permite validar todas as detecções sem esforço.
```{r}
# Tempo de processamento: detecções filtradas
system.time({
    validate_by_overlap(
        df_detecs = df_detecs, df_rois = df_rois, validation_user = "User"
    )
})
# Tempo de processamento: detecções não filtradas
system.time({
    validate_by_overlap(
        df_detecs = df_detecs_nofilt, df_rois = df_rois, validation_user = "User"
    )
})
```

### 5.3. Validação a posteriori (manual)
Quando não há ROIs pré-marcadas, a validação deve ser feita manualmente usando o app interativo. Primeiro, fazemos uma cópia do arquivo de detecções para preservar os dados originais.
```{r eval=FALSE}
file.copy(
    from = "./detections/df_detecs.csv",
    to = "./detections/df_detecs_aposteriori.csv",
    overwrite = FALSE
)
```

Abre o app de validação manual. No app, você visualiza cada detecção junto com o template correspondente e classifica como TP ou FP. O resultado será salvo no arquivo `./detections/df_detecs_aposteriori.csv`.
```{r eval=FALSE}
launch_validation_app(
    project_path = ".", validation_user = "User",
    templates_path = "./templates/", soundscapes_path = "./soundscapes/",
    input_path = "./detections/df_detecs_aposteriori.csv",
    output_path = "./detections/df_detecs_aposteriori.csv",
    dyn_range_templ = c(-78, -30), dyn_range_detec = c(-78, -30), wl = 1024,
    ovlp = 70, time_guide_interval = 0, freq_guide_interval = 0,
    overwrite = TRUE
)
```

### 5.4. Importar resultados da validação a posteriori
Importa o arquivo de detecções validadas manualmente de volta ao ambiente de trabalho.
```{r eval=FALSE}
df_detecs_aposteriori <- read.csv(
    file = "./detections/df_detecs_aposteriori.csv"
)
glimpse(df_detecs_aposteriori)
```

```{r eval=FALSE}
table(
    df_detecs_aposteriori$validation,
    df_detecs_aposteriori$template_name
)
```

### 5.5. Comparar validações a priori e a posteriori
Compara os resultados dos dois métodos de validação. Note que a validação a posteriori não permite contagem de FN, pois não há ROIs pré-marcadas como referência.
```{r eval=FALSE}
df_rois %>%
    filter(!grepl("Bcu", soundscape_file)) %>%
    nrow()
```

```{r eval=FALSE}
nrow(df_detecs_aposteriori)
```

```{r eval=FALSE}
table(df_detecs_aposteriori$validation, df_detecs_aposteriori$template_name)
```

## 6. Diagnósticos de performance e resultados finais

### 6.1. Diagnósticos de performance

Avaliação de métricas de performance é essencial para otimizar o template matching:

- **Precision (precisão):** proporção de detecções que são verdadeiras
- **Recall (sensibilidade):** proporção de ocorrências do sinal que foram detectadas

Existe uma relação de trade-off: aumentar o limiar de score aumenta a precisão (menos FP) mas diminui o recall (mais FN), e vice-versa. A escolha do limiar ideal depende do objetivo: minimizar falsos positivos, maximizar detecções ou buscar um equilíbrio.

Calcula diagnósticos de performance para cada template, incluindo métricas em função de diferentes limiares de score.
```{r}
ls_val_apriori <- diagnostic_validations(
    df_validated = df_validated, pos_prob = 0.90, val_a_priori = TRUE
)
# Extrai resultados para cada template
res_template1 <- ls_val_apriori[[1]]
res_template2 <- ls_val_apriori[[2]]
```

Inspeciona os diagnósticos: cada data frame contém métricas de performance (precision, recall, etc.) calculadas para diferentes limiares de score.
```{r}
res_template1$diagnostics %>% glimpse()
res_template2$diagnostics %>% glimpse()
```

Visualiza os gráficos de performance para cada template:
- **Coluna 1:** template 1 (subestrutura do canto)
- **Coluna 2:** template 2 (canto completo)
- **Linha 1:** modelos binomiais (probabilidade posterior de 95% de detecção verdadeira)
- **Linha 2:** precisão e recall em função dos limiares de score

As linhas vermelhas indicam os limiares de score selecionados para cada template.
```{r}
cowplot::plot_grid(
    res_template1$mod_plot, res_template2$mod_plot,
    res_template1$precrec_plot, res_template2$precrec_plot,
    ncol = 2
)
```

### 6.2. Obter conjunto final de detecções
Extrai os limiares de score ótimos calculados nos diagnósticos e filtra as detecções para manter apenas aquelas acima desses limiares.

#### 6.2.1. Extrair limiares e nomes dos templates
Extrai os limiares de score ótimos e os nomes dos templates dos resultados dos diagnósticos.
```{r}
# Limiares de score ótimos para cada template
template1_score <- ls_val_apriori[[1]]$score_cut
template2_score <- ls_val_apriori[[2]]$score_cut

# Nomes dos templates
template1_name <- ls_val_apriori[[1]]$diagnostics$template_name[1]
template2_name <- ls_val_apriori[[2]]$diagnostics$template_name[1]
```

#### 6.2.2. Filtrar detecções do template 1
Filtra as detecções mantendo apenas aquelas do template 1 com score maior ou igual ao limiar ótimo.
```{r}
df_detecs_final_1 <- df_detecs %>%
    filter(
        template_name == template1_name & peak_score >= template1_score
    ) %>%
    glimpse()
```

Visualização das detecções do template 1.
```{r eval=TRUE, include=FALSE}
detection_plots1 <- df_detecs_final_1 %>%
    split(., seq(nrow(.))) %>%
    purrr::map(., ~ {
        wav <- tuneR::readWave(
            filename = .x$soundscape_path, from = .x$detection_start, to = .x$detection_end, units = "seconds"
        )
        res <- fast_spectro(
            rec = wav, f = wav@samp.rate, wl = 512, ovlp = 90,
            dyn_range = c(-102, -42), color_scale = "greyscale 1",
            freq_guide_interval = 0, time_guide_interval = 0,
            zoom_freq = c(
                .x$template_min_freq,
                .x$template_max_freq
            )
        ) +
            theme_bw() +
            theme(legend.position = "none")
        return(res)
    }, .progress = TRUE)
length(detection_plots1)

cowplot::plot_grid(
    detection_plots1[[1]], detection_plots1[[2]],
    detection_plots1[[3]], detection_plots1[[4]],
    detection_plots1[[5]], detection_plots1[[6]],
    detection_plots1[[7]], detection_plots1[[8]],
    detection_plots1[[9]], detection_plots1[[10]],
    detection_plots1[[11]], detection_plots1[[12]],
    ncol = 4
)
```

#### 6.2.3. Filtrar detecções do template 2
Filtra as detecções mantendo apenas aquelas do template 2 com score maior ou igual ao limiar ótimo.
```{r}
df_detecs_final_2 <- df_detecs %>%
    filter(
        template_name == template2_name & peak_score >= template2_score
    ) %>%
    glimpse()
```

Visualização das detecções do template 2.
```{r eval=TRUE, include=FALSE}
detection_plots2 <- df_detecs_final_2 %>%
    split(., seq(nrow(.))) %>%
    purrr::map(., ~ {
        wav <- tuneR::readWave(
            filename = .x$soundscape_path, from = .x$detection_start, to = .x$detection_end, units = "seconds"
        )
        res <- fast_spectro(
            rec = wav, f = wav@samp.rate, wl = 1024, ovlp = 70,
            dyn_range = c(-102, -42), color_scale = "greyscale 1",
            freq_guide_interval = 0, time_guide_interval = 0,
            zoom_freq = c(
                .x$template_min_freq,
                .x$template_max_freq
            )
        ) +
            theme_bw() +
            theme(legend.position = "none")
        return(res)
    }, .progress = TRUE)
length(detection_plots2)

cowplot::plot_grid(
    detection_plots2[[1]], detection_plots2[[2]],
    detection_plots2[[3]], detection_plots2[[4]],
    detection_plots2[[5]], detection_plots2[[6]],
    detection_plots2[[7]], detection_plots2[[8]],
    detection_plots2[[9]], detection_plots2[[10]],
    ncol = 5
)
```

### 6.3. Converter detecções finais em tabelas de ROIs
Converte as detecções filtradas em formato de tabelas de ROIs, que podem ser exportadas e usadas em outros aplicativos ou análises.
```{r eval=FALSE}
dir.create("./final_detecs", showWarnings = FALSE)
df_final <- rbind(df_detecs_final_1, df_detecs_final_2) %>% glimpse()
df_rois_final <- detecs_to_rois(
    df_detecs = df_final, username = "User",
    output_path = "./final_detecs/"
)
```

## Considerações finais

### Resumo do processo

Ao longo deste tutorial, realizamos o processamento completo de detecções acústicas utilizando dois templates distintos. O fluxo incluiu: (1) preparação e organização dos dados de entrada (templates e soundscapes), (2) execução do template matching usando diferentes abordagens (simplificada e detalhada), (3) validação das detecções através de métodos a priori ou a posteriori, (4) análise de performance e otimização de limiares, e (5) geração de resultados finais em formatos reutilizáveis.

A estrutura de diretórios e organização dos dados ao longo do processo permite que os resultados sejam revisitados de forma rápida e eficiente, bem como adaptados para diferentes contextos de uso. Os arquivos intermediários (metadados, scores brutos, detecções filtradas) podem ser utilizados para análises adicionais ou ajustes posteriores sem necessidade de reprocessar todo o pipeline.

### Adaptação para diferentes projetos

Este fluxo de análise pode ser adaptado para diferentes projetos em termos de escala e complexidade:

- **Monitoramento de populações:** pode requerer o uso de múltiplos templates quando a espécie alvo apresentar repertórios vocais mais complexos, além da aplicação de filtros adicionais para reduzir o número de detecções falsas. A validação sistemática se torna ainda mais importante nesses casos.

- **Monitoramento de comunidades:** adiciona uma camada extra de complexidade devido à necessidade de detecção de múltiplas espécies simultaneamente. Nesse contexto, recomenda-se processar cada espécie separadamente ou criar pipelines paralelos para diferentes grupos taxonômicos.

- **Projetos em larga escala:** para grandes volumes de dados, considere usar o processo detalhado (seções 4.2-4.5) para maior controle sobre a filtragem e processamento, bem como usar o processamento em paralelo para maior eficiência.

### Próximos passos e extensões

Algumas coisas a explorar quando começar a usar o monitoraSom para seu próprio projeto:

- **Ajuste fino de parâmetros:** experimente diferentes configurações de `wl`, `ovlp`, `dyn_range` e `buffer_size` para otimizar a detecção de acordo com as características acústicas específicas do seu projeto.

- **Integração com outros pacotes:** os dados exportados podem ser facilmente integrados com outros pacotes do R para análise de morfometria, modelagem ecológica, ecologia espacial, fenologia, etc.

- **Automação de workflows:** para projetos repetitivos, considere criar scripts automatizados que combinem múltiplas etapas do processo, reduzindo o tempo de processamento e aumentando a reprodutibilidade.

### Boas práticas recomendadas

1. **Documentação:** mantenha scripts organizados e registros dos parâmetros utilizados em cada etapa, especialmente limiares de score e configurações de filtragem.

2. **Validação contínua:** mesmo com validação a priori, revise a performance dos templates periodicamente, especialmente após a entrada de novos conjuntos de dados para garantir que os resultados não se deteriorem como consequência de mudanças ambientais..

3. **Backup de dados:** preserve os arquivos de scores brutos e detecções não filtradas, pois permitem reavaliação sem reprocessamento completo.

4. **Controle de versão:** use sistemas de controle de versão (ex: Git) para rastrear mudanças em scripts e parâmetros ao longo do projeto.

### Suporte e contribuições

Nós, os desenvolvedores do monitoraSom, estamos sempre abertos a sugestões e melhorias para o pacote. Se você tiver alguma ideia, encontrar um bug, ou quiser contribuir com o desenvolvimento, por favor, entre em contato conosco através do nosso canal de comunicação do GitHub: https://github.com/ConservaSom/monitoraSom/issues.

Para documentação adicional, exemplos avançados e atualizações do pacote, visite nosso repositório: https://github.com/ConservaSom/monitoraSom.

Para informações mais completas e embasamento teórico sobre o monitoraSom, visite nosso preprint: https://www.biorxiv.org/content/10.1101/2025.06.23.661148v1.

**Boa sorte nas descobertas a seguir!**